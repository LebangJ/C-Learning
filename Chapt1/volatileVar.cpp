//volatile 直译「易变的」，核心作用是 「告诉编译器：放弃对该变量的所有优化，强制每次访问都直接读写「内存原值」，绝不使用寄存器缓存值」。
//为什么需要volatile？（编译器优化的坑)C++ 编译器默认会做「数据缓存优化」：将频繁访问的变量值，临时缓存到 CPU 寄存器中（寄存器读写速度 ≫ 内存），后续访问直接读寄存器，而非内存。
//被修饰的变量，只要满足以下任意一种情况，就必须加volatile：

    //硬件编程：变量映射到硬件寄存器地址（如单片机、驱动开发中的寄存器，值会被硬件自动修改）；
    //多线程开发：变量被多个线程同时访问 / 修改（其他线程的修改，当前线程编译器无法感知）；
    //中断处理：变量在中断服务函数中被修改（主程序的编译器，无法感知中断对变量的修改）。
#include <iostream>
using namespace std;

// 模拟：将0x1000地址映射为硬件状态寄存器（值会被硬件实时修改）
// 必须加volatile：强制每次读取都从0x1000内存地址取值，不缓存
#define DEVICE_STATUS (*(volatile unsigned int*)0x1000)
//将物理内存地址 0x1000 封装为一个「可直接读写的变量名 DEVICE_STATUS」，把该地址当作32 位无符号整型硬件寄存器使用，且强制禁止编译器对该地址的任何访问优化。
//*指针 就是变量本身，所有对普通变量的合法操作，对解引用后的指针都完全适用
//解引用指针就是变量的临时别名，定义指针是设置一个固定别名
int main() {
    // 等待硬件就绪：循环读取寄存器值，直到状态为1
    while (DEVICE_STATUS == 0) {
        // 若无volatile，编译器会优化为「只读1次寄存器，之后一直读缓存」
        // 即使硬件修改了寄存器值，程序也永远感知不到，陷入死循环
    }
    cout << "硬件就绪，开始工作" << endl;
    return 0;
}
